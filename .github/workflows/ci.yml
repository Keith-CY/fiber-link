name: CI

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name == 'pull_request' && github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs:
  test-service:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.1.8
      - name: Cache Bun install artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            fiber-link-service/node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('fiber-link-service/bun.lockb') }}-service
          restore-keys: |
            ${{ runner.os }}-bun-
      - name: Install dependencies
        working-directory: fiber-link-service
        run: bun install --frozen-lockfile
      - name: Check db migration drift
        working-directory: fiber-link-service/packages/db
        run: bun run db:validate
      - name: Test rpc
        working-directory: fiber-link-service/apps/rpc
        run: bun run test -- --run --silent
      - name: Test admin
        working-directory: fiber-link-service/apps/admin
        run: bun run test -- --run --silent
      - name: Test worker
        working-directory: fiber-link-service/apps/worker
        run: bun run test -- --run --silent
      - name: Test db
        working-directory: fiber-link-service/packages/db
        run: bun run test -- --run --silent


  coverage-comment:
    name: Coverage Comment
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.1.8
      - name: Cache Bun install artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            fiber-link-service/node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('fiber-link-service/bun.lockb') }}-coverage
          restore-keys: |
            ${{ runner.os }}-bun-
      - name: Install service dependencies
        working-directory: fiber-link-service
        run: bun install --frozen-lockfile
      - name: Collect Vitest coverage
        working-directory: fiber-link-service
        run: |
          set -euo pipefail
          mkdir -p coverage-reports
          run_pkg() {
            local pkg="$1"
            local name="$2"
            local report_dir="../../coverage-reports/$name"
            local status_file="$report_dir/.status"

            mkdir -p "$report_dir"
            rm -f "$status_file"

            if [ ! -d "$pkg" ]; then
              echo "missing" > "$status_file"
              echo "::warning title=head-coverage-missing::PR package not found: $pkg"
              return 0
            fi

            if (cd "$pkg" && bunx vitest run --silent --coverage.enabled --coverage.provider=v8 --coverage.reporter=json-summary --coverage.reportsDirectory="$report_dir"); then
              echo "ok" > "$status_file"
              return 0
            fi

            echo "failed" > "$status_file"
            echo "::warning title=head-coverage-failed::Head coverage collection failed for $pkg"
          }
          run_pkg apps/rpc rpc
          run_pkg apps/admin admin
          run_pkg apps/worker worker
          run_pkg packages/db db

      - name: Collect base branch coverage
        working-directory: fiber-link-service
        run: |
          set -euo pipefail
          base_dir="$(mktemp -d)"
          trap 'git worktree remove -f "$base_dir/_base_cov" || true; rm -rf "$base_dir"' EXIT
          base_ref="origin/${{ github.event.pull_request.base.ref }}"
          base_root="${base_dir}/_base_cov"
          mkdir -p "${base_dir}/base-coverage-reports"
          git fetch --no-tags origin "${{ github.event.pull_request.base.ref }}"
          git worktree add --detach "$base_root" "$base_ref"

          (cd "$base_root/fiber-link-service" && bun install --frozen-lockfile)
          # base branch may not include coverage provider dependency yet
          (cd "$base_root/fiber-link-service" && bun add -d @vitest/coverage-v8@1.6.0)

          run_base_pkg() {
            local pkg="$1"
            local name="$2"
            local report_dir="$base_dir/base-coverage-reports/$name"
            local pkg_root="$base_root/fiber-link-service/$pkg"
            local status_file="$report_dir/.status"

            mkdir -p "$report_dir"
            rm -f "$status_file"
            if [ ! -d "$pkg_root" ]; then
              echo "missing" > "$status_file"
              echo "::warning title=base-coverage-missing::Base package not found: $pkg"
              return 0
            fi

            if ! (cd "$pkg_root" && bunx vitest run --silent --coverage.enabled --coverage.provider=v8 --coverage.reporter=json-summary --coverage.reportsDirectory="$report_dir"); then
              echo "failed" > "$status_file"
              echo "::warning title=base-coverage-failed::Base coverage collection failed for $pkg"
              return 0
            fi
            echo "ok" > "$status_file"
          }

          run_base_pkg apps/rpc rpc
          run_base_pkg apps/admin admin
          run_base_pkg apps/worker worker
          run_base_pkg packages/db db
          mkdir -p ../base-coverage-reports
          cp -R "$base_dir/base-coverage-reports/" ../base-coverage-reports

      - name: Build markdown summary
        working-directory: fiber-link-service
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');

          function readCoveragePercent(filePath) {
            if (!fs.existsSync(filePath)) {
              return null;
            }
            try {
              const json = JSON.parse(fs.readFileSync(filePath, 'utf8'));
              const value = json?.total?.lines?.pct;
              const num = Number(value);
              return Number.isFinite(num) ? num : null;
            } catch (error) {
              console.error(`Failed to parse coverage file: ${filePath}`, error.message);
              return null;
            }
          }

          function formatPct(value) {
            if (!Number.isFinite(value)) {
              return 'N/A';
            }
            return `${value.toFixed(2)}%`;
          }

          function formatCoverageValue(filePath, statusPath) {
            const status = fs.existsSync(statusPath)
              ? fs.readFileSync(statusPath, 'utf8').trim()
              : 'unknown';
            if (status === 'ok') {
              const value = readCoveragePercent(filePath);
              return { value, status };
            }
            if (status === 'missing') {
              return { value: null, status: 'missing' };
            }
            if (status === 'failed') {
              return { value: null, status: 'failed' };
            }
            return { value: readCoveragePercent(filePath), status: 'unknown' };
          }

          function statusLabel(status, value) {
            if (status === 'ok') {
              return formatPct(value);
            }
            if (status === 'missing') {
              return 'N/A (missing)';
            }
            if (status === 'failed') {
              return 'N/A (failed)';
            }
            return 'N/A';
          }

          function buildStatus(headCoverage, baseCoverage) {
            const reasons = [];
            if (headCoverage.status !== 'ok') {
              reasons.push(`head:${headCoverage.status}`);
            }
            if (baseCoverage.status !== 'ok') {
              reasons.push(`base:${baseCoverage.status}`);
            }
            if (reasons.length === 0) {
              return '‚úÖ';
            }
            const icons = reasons.map((reason) =>
              reason.includes('failed') ? `‚ùå ${reason}` : `‚ö†Ô∏è ${reason}`
            );
            return icons.join('<br>');
          }

          function statusPriority(status) {
            if (status === 'failed') {
              return 0;
            }
            if (status === 'missing') {
              return 1;
            }
            return 2;
          }

          function buildDeltaDisplay(pct, basePct, headCoverage, baseCoverage) {
            if (Number.isFinite(pct) && Number.isFinite(basePct)) {
              const delta = pct - basePct;
              return `${delta >= 0 ? '+' : ''}${delta.toFixed(2)}%`;
            }

            const headStatus = headCoverage.status;
            const baseStatus = baseCoverage.status;
            if (headStatus !== 'ok' && baseStatus !== 'ok') {
              return `N/A (both failed: ${headStatus}/${baseStatus})`;
            }
            if (headStatus !== 'ok') {
              return `N/A (head unavailable: ${headStatus})`;
            }
            return `N/A (base unavailable: ${baseStatus})`;
          }

          const targets = [
            ['rpc','RPC'],
            ['admin','Admin'],
            ['worker','Worker'],
            ['db','DB'],
          ];

          let rows = [];
          let sum = 0;
          let baseSum = 0;
          let headCount = 0;
          let baseCount = 0;
          let pairCount = 0;
          let pairDeltaSum = 0;
          let actionItems = [];

          for (const [key,label] of targets) {
            const p = path.join('coverage-reports', key, 'coverage-summary.json');
            const bp = path.join('..', 'base-coverage-reports', key, 'coverage-summary.json');
            const ps = path.join('coverage-reports', key, '.status');
            const bs = path.join('..', 'base-coverage-reports', key, '.status');

            const headCoverage = formatCoverageValue(p, ps);
            const baseCoverage = formatCoverageValue(bp, bs);
            const pct = headCoverage.value;
            const basePct = baseCoverage.value;
            if (headCoverage.status === 'ok' && Number.isFinite(pct)) {
              sum += pct;
              headCount += 1;
            }
            if (baseCoverage.status === 'ok' && Number.isFinite(basePct)) {
              baseSum += basePct;
              baseCount += 1;
            }
            const headStr = statusLabel(headCoverage.status, pct);
            const delta = Number.isFinite(pct) && Number.isFinite(basePct)
              ? pct - basePct
              : null;
            const deltaDisplay = buildDeltaDisplay(pct, basePct, headCoverage, baseCoverage);
            if (headCoverage.status === 'ok' && baseCoverage.status === 'ok' && Number.isFinite(delta)) {
              pairDeltaSum += delta;
              pairCount += 1;
            }

            if (headCoverage.status !== 'ok' || baseCoverage.status !== 'ok') {
              actionItems.push({
                module: label,
                headStatus: headCoverage.status,
                baseStatus: baseCoverage.status,
                statusLabel: buildStatus(headCoverage, baseCoverage),
                priority: Math.min(statusPriority(headCoverage.status), statusPriority(baseCoverage.status)),
              });
            }

            rows.push(`| ${label} | ${headCoverage.status === 'ok' ? formatPct(pct) : headStr} | ${deltaDisplay} | ${buildStatus(headCoverage, baseCoverage)} |`);
          }

          actionItems.sort((a, b) => {
            if (a.priority !== b.priority) {
              return a.priority - b.priority;
            }
            return a.module.localeCompare(b.module);
          });

          const actionableLines = actionItems.length > 0
            ? actionItems.map((item) => {
                const failureLabel = [item.headStatus !== 'ok' ? `head:${item.headStatus}` : '', item.baseStatus !== 'ok' ? `base:${item.baseStatus}` : '']
                  .filter(Boolean)
                  .join(', ');
                const action = item.priority === 0
                  ? `‚ö†Ô∏è fix coverage run errors and retry this job`
                  : `‚ö†Ô∏è verify module exists and is available on both branches`;
                return `- **${item.module}**: ${item.statusLabel} (${failureLabel}) ‚Äî ${action}`;
              }).join('\n')
            : '- ‚úÖ No action needed.';

          const avg = headCount > 0 ? sum / headCount : null;
          const baseAvg = baseCount > 0 ? baseSum / baseCount : null;
          const avgDelta = pairCount > 0 ? pairDeltaSum / pairCount : null;
          const marker = '<!-- fiber-link-pr-coverage-report -->';
          const effectiveModules = `Modules with head/base coverage: ${pairCount}/${targets.length}`;
          const body = [
            marker,
            '### üìä Coverage Report',
            '',
            '| Module | Line Coverage | Œî vs base | Status |',
            '|---|---:|---:|:---|',
            ...rows,
            '',
            `**Average line coverage:** ${formatPct(avg)}`,
            `**Base average line coverage:** ${formatPct(baseAvg)}`,
            `**Œî vs base:** ${Number.isFinite(avgDelta) ? `${avgDelta >= 0 ? '+' : ''}${avgDelta.toFixed(2)}%` : 'N/A'}`,
            `**Compared modules:** ${effectiveModules}`,
            '',
            '### Action needed',
            actionableLines,
            '',
            '- To recalc the report after fixes: open this workflow run and rerun **Coverage Comment** job.',
            '',
            '_Status legend: ‚úÖ OK, ‚ö†Ô∏è module missing, ‚ùå module coverage run failed._',
          ].join('\n');
          fs.writeFileSync('../coverage-comment.md', body);
          NODE
      - name: Create or update PR comment
        if: github.event.pull_request.head.repo.full_name == github.repository
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          marker='<!-- fiber-link-pr-coverage-report -->'
          pr='${{ github.event.pull_request.number }}'
          body=$(cat coverage-comment.md)
          ids=$(gh api "repos/${GITHUB_REPOSITORY}/issues/${pr}/comments" --paginate \
            | jq -r --arg m "$marker" '.[] | select(.body | contains($m)) | .id')
          existing_id=$(printf '%s\n' "$ids" | sed '/^$/d' | head -n1)
          if [ -n "${existing_id:-}" ]; then
            gh api -X PATCH "repos/${GITHUB_REPOSITORY}/issues/comments/${existing_id}" -f body="$body" >/dev/null
            printf '%s\n' "$ids" | sed '/^$/d' | tail -n +2 | while read -r extra_id; do
              gh api -X DELETE "repos/${GITHUB_REPOSITORY}/issues/comments/${extra_id}" >/dev/null || true
            done
          else
            gh api "repos/${GITHUB_REPOSITORY}/issues/${pr}/comments" -f body="$body" >/dev/null
          fi

      - name: Skip comment for fork PR
        if: github.event.pull_request.head.repo.full_name != github.repository
        run: |
          echo "Skipping coverage comment update for forked PR (${GITHUB_REPOSITORY})."

  fiber-adapter-e2e:
    runs-on: ubuntu-latest
    timeout-minutes: 40
    steps:
      - uses: actions/checkout@v4

      - name: Prepare compose env
        run: |
          cat > deploy/compose/.env <<'EOF'
          POSTGRES_DB=fiber_link
          POSTGRES_USER=fiber
          POSTGRES_PASSWORD=ci-postgres-password
          POSTGRES_PORT=5432
          REDIS_PORT=6379
          RPC_PORT=3000
          FNN_VERSION=v0.6.1
          FNN_ASSET=fnn_v0.6.1-x86_64-linux-portable.tar.gz
          FNN_ASSET_SHA256=8f9a69361f662438fa1fc29ddc668192810b13021536ebd1101c84dc0cfa330f
          FNN_PLATFORM=linux/amd64
          FNN_RPC_PORT=8227
          FNN_P2P_PORT=8228
          FIBER_SECRET_KEY_PASSWORD=ci-fiber-secret-password
          FIBER_LINK_HMAC_SECRET=ci-hmac-secret
          FIBER_RPC_URL=http://fnn:8227
          RPC_HEALTHCHECK_TIMEOUT_MS=3000
          WORKER_WITHDRAWAL_INTERVAL_MS=30000
          WORKER_SETTLEMENT_INTERVAL_MS=30000
          WORKER_SETTLEMENT_BATCH_SIZE=200
          WORKER_MAX_RETRIES=3
          WORKER_RETRY_DELAY_MS=60000
          WORKER_SETTLEMENT_MAX_RETRIES=3
          WORKER_SETTLEMENT_RETRY_DELAY_MS=60000
          WORKER_SETTLEMENT_PENDING_TIMEOUT_MS=1800000
          WORKER_SETTLEMENT_CURSOR_FILE=/var/lib/fiber-link/settlement-cursor.json
          WORKER_SHUTDOWN_TIMEOUT_MS=15000
          WORKER_READINESS_TIMEOUT_MS=5000
          EOF

      - name: Run fiber-adapter docker e2e
        run: scripts/e2e-fiber-adapter-docker.sh

      - name: Dump compose logs on failure
        if: failure()
        run: docker compose -f deploy/compose/docker-compose.yml logs --no-color || true

      - name: Compose cleanup
        if: always()
        run: docker compose -f deploy/compose/docker-compose.yml down -v --remove-orphans || true

  plugin-smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      # Pin Discourse ref to reduce upstream-induced CI breakage. Update as needed.
      DISCOURSE_REF: 26f3e2aa87a3abb35849183e0740fe7ab84cec67
      DISCOURSE_DEV_IMAGE: discourse/discourse_dev:release
      # Keep request spec scope explicit in CI; add more paths via PLUGIN_SMOKE_EXTRA_SPECS as needed.
      PLUGIN_SMOKE_REQUEST_SPECS: "plugins/fiber-link/spec/requests/fiber_link_spec.rb plugins/fiber-link/spec/requests/fiber_link/rpc_controller_spec.rb"
      PLUGIN_SMOKE_EXTRA_SPECS: ""
    steps:
      - uses: actions/checkout@v4

      - name: Checkout Discourse (pinned)
        run: |
          git clone https://github.com/discourse/discourse.git discourse-dev
          cd discourse-dev
          git checkout "$DISCOURSE_REF"

      - name: Copy plugin into Discourse plugins/
        run: |
          rm -rf discourse-dev/plugins/fiber-link
          cp -R fiber-link-discourse-plugin discourse-dev/plugins/fiber-link

      - name: Start Discourse dev container
        working-directory: discourse-dev
        run: |
          docker pull "$DISCOURSE_DEV_IMAGE"
          mkdir -p data/postgres
          chmod -R 777 data/postgres
          docker run -d \
            --name discourse_dev \
            --hostname discourse \
            -v "$PWD/data/postgres:/shared/postgres_data" \
            -v "$PWD:/src" \
            -e UNICORN_BIND_ALL=true \
            "$DISCOURSE_DEV_IMAGE" /sbin/boot

      - name: Fix checkout permissions for container user
        working-directory: discourse-dev
        run: |
          docker exec -u root discourse_dev bash -lc \
            "chown -R discourse:discourse /src && chmod -R u+rwX /src"

      - name: Install Discourse gems
        working-directory: discourse-dev
        run: docker exec -u discourse:discourse -w /src discourse_dev bundle install

      - name: Install Discourse JS deps
        working-directory: discourse-dev
        run: docker exec -u discourse:discourse -w /src discourse_dev pnpm install

      - name: Wait for Postgres
        working-directory: discourse-dev
        run: |
          docker exec -u root discourse_dev bash -lc \
            'for i in {1..180}; do [ -S /var/run/postgresql/.s.PGSQL.5432 ] && exit 0; sleep 1; done; echo "postgres socket not ready after 180s"; exit 1'
          docker logs discourse_dev | tail -n 200 || true

      - name: Prepare test DB
        working-directory: discourse-dev
        run: docker exec -u discourse:discourse -w /src -e RAILS_ENV=test -e LOAD_PLUGINS=1 discourse_dev bin/rake db:create db:migrate

      - name: Plugin smoke spec (requests + optional extras)
        working-directory: discourse-dev
        run: |
          docker exec -u discourse:discourse -w /src \
            -e RAILS_ENV=test -e LOAD_PLUGINS=1 \
            -e PLUGIN_SMOKE_REQUEST_SPECS -e PLUGIN_SMOKE_EXTRA_SPECS \
            discourse_dev bash -lc '
              set -euo pipefail

              specs=($PLUGIN_SMOKE_REQUEST_SPECS)
              if [ -n "${PLUGIN_SMOKE_EXTRA_SPECS:-}" ]; then
                specs+=($PLUGIN_SMOKE_EXTRA_SPECS)
              fi

              bundle exec rspec "${specs[@]}"
            '

      - name: Shutdown Discourse dev container
        if: always()
        run: docker rm -f discourse_dev
