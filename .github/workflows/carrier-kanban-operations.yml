name: Fiber Link Kanban Operations

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Report only, do not post to Discussions.'
        required: false
        default: 'false'
  schedule:
    - cron: '0 9 * * 1'

permissions:
  contents: read
  issues: read
  pull-requests: read
  repository-projects: read
  discussions: write

jobs:
  sync-config-and-report:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Publish Kanban field/view status to Discussion
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        env:
          FIBER_LINK_CANONICAL_PROJECT_ID: ${{ vars.FIBER_LINK_CANONICAL_PROJECT_ID }}
        with:
          github-token: ${{ secrets.FIBER_LINK_PROJECTS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const { DEFAULT_PROJECT_ID, resolveProjectIdFromCandidates } = require('./.github/scripts/kanban-project-id');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const dryRunInput = String((context.payload.inputs?.dry_run || process.env.DRY_RUN || 'false')).toLowerCase() === 'true';
            const ghClient = github;

            let repoMeta = null;
            try {
              repoMeta = await ghClient.graphql(`
                query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    id
                    discussionCategories(first: 20) {
                      nodes {
                        id
                        name
                        slug
                      }
                    }
                  }
                }
              `, { owner, repo });
            } catch (error) {
              core.warning(`Discussion metadata is not accessible in this workflow run: ${(error && error.message) ? error.message : error}`);
            }

            const configPath = '.github/kanban-config.json';
            if (!fs.existsSync(configPath)) {
              core.setFailed(`Missing configuration file: ${configPath}`);
              return;
            }

            const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
            const projectCandidates = [
              process.env.FIBER_LINK_PROJECT_ID,
              process.env.FIBER_LINK_CANONICAL_PROJECT_ID,
              config.projectId,
              DEFAULT_PROJECT_ID,
            ];
            const projectId = await resolveProjectIdFromCandidates(projectCandidates, {
              graphql: ghClient.graphql,
              log: (message) => core.info(message),
            });

            if (!projectId) {
              core.setFailed('Missing projectId. Set vars.FIBER_LINK_CANONICAL_PROJECT_ID, FIBER_LINK_PROJECT_ID secret, or ensure .github/kanban-config.json contains projectId.');
              return;
            }

            let preflight = null;
            let projectLookupError = null;
            try {
              preflight = await ghClient.graphql(`
                query($projectId: ID!) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      id
                      title
                      fields(first: 200) {
                        nodes {
                          ... on ProjectV2Field {
                            id
                            name
                            dataType
                          }
                          ... on ProjectV2SingleSelectField {
                            options {
                              id
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `, { projectId });
            } catch (error) {
              projectLookupError = error && (error.message || String(error));
              core.warning(`Unable to read ProjectV2 ${projectId} in this run: ${projectLookupError}`);
            }

            if (!preflight?.node) {
              core.info(`Project validation skipped. ProjectV2 ${projectId} is not directly accessible to this token.`);
            }

            const existingFields = preflight?.node?.fields?.nodes || [];
            const fieldByName = new Map(existingFields.map((f) => [String(f.name || '').toLowerCase(), f]));

            const normalize = (text) => String(text || '').trim().toLowerCase();

            const findField = (names = []) => {
              for (const name of names) {
                const found = fieldByName.get(normalize(name));
                if (found) {
                  return found;
                }
              }
              return null;
            };

            const requiredReport = config.fields.map((field) => {
              const existing = findField(field.aliases || [field.name]);
              if (!existing) {
                return {
                  field: field.name,
                  status: 'missing',
                  reason: `field not found. expected aliases: ${(field.aliases || [field.name]).join(', ')}`,
                };
              }

              const expectedDataType = field.type;
              if (expectedDataType && existing.dataType && String(existing.dataType) !== String(expectedDataType)) {
                return {
                  field: field.name,
                  status: 'type_mismatch',
                  reason: `existing type: ${existing.dataType}, expected: ${expectedDataType}`,
                };
              }

              if (String(existing.dataType) === 'SINGLE_SELECT' && Array.isArray(field.options)) {
                const exists = new Set((existing.options || []).map((o) => normalize(o.name)));
                const missingOptions = field.options.filter((option) => !exists.has(normalize(option)));
                if (missingOptions.length > 0) {
                  return {
                    field: field.name,
                    status: 'partial',
                    reason: `missing options: ${missingOptions.join(', ')}`,
                  };
                }
              }

              return {
                field: field.name,
                status: 'ok',
                reason: 'configured',
              };
            });

            const now = new Date();
            const isoDate = now.toISOString().split('T')[0];

            const parseEstimate = (text) => {
              if (!text) return null;
              const source = String(text);
              const estimateMatchers = [
                /(?:^|\s)estimate[:：]?\s*(\d+(?:\.\d+)?)/i,
                /(?:^|\s)预估[:：]?\s*(\d+(?:\.\d+)?)/i,
                /(?:^|\s)(?:story\s*points|sp|points)[:：]?\s*(\d+(?:\.\d+)?)/i,
              ];

              for (const matcher of estimateMatchers) {
                const match = source.match(matcher);
                if (match && match[1]) {
                  const value = Number.parseFloat(match[1]);
                  return Number.isFinite(value) ? value : null;
                }
              }

              return null;
            };

            const normalizeLabel = (name) => String(name || '').trim().toLowerCase();

            const inferStatus = (item, labelNames) => {
              if (item.state === 'closed') {
                return 'Done';
              }

              if (labelNames.has('blocked') || labelNames.has('blocker')) {
                return 'Blocked';
              }

              if (labelNames.has('in progress') || labelNames.has('in-progress') || labelNames.has('wip') || labelNames.has('review')) {
                return 'In Progress';
              }

              return 'To Do';
            };

            const issueOpts = { owner, repo, state: 'open', per_page: 100 };
            const issues = await github.paginate(github.rest.issues.listForRepo, issueOpts, (r) => r.data);

            const workload = new Map();
            const blockedItems = [];

            for (const item of issues) {
              const labels = new Set((item.labels || []).map((label) => normalizeLabel(label.name)));
              const status = inferStatus(item, labels);
              const estimates = parseEstimate([item.title, item.body || ''].join(' '));
              const estimateHours = estimates == null ? 0 : estimates;
              const owners = (item.assignees || []).map((a) => a?.login).filter(Boolean);
              const assignees = owners.length > 0 ? Array.from(new Set(owners)) : ['unassigned'];

              for (const assignee of assignees) {
                if (!workload.has(assignee)) {
                  workload.set(assignee, {
                    todo: 0,
                    inProgress: 0,
                    blocked: 0,
                    done: 0,
                    totalEstimate: 0,
                  });
                }

                const bucket = workload.get(assignee);
                if (status === 'Blocked') {
                  bucket.blocked += 1;
                  blockedItems.push({
                    title: item.title,
                    url: item.html_url,
                    assignee,
                    labels: Array.from(labels).slice(0, 5).join(', ') || '-',
                    estimate: estimateHours,
                  });
                } else if (status === 'In Progress') {
                  bucket.inProgress += 1;
                } else {
                  bucket.todo += 1;
                }

                bucket.totalEstimate += estimateHours;
              }
            }

            const totalItems = issues.length;
            const totalBlocked = blockedItems.length;
            const totalInProgress = Array.from(workload.values()).reduce((sum, value) => sum + value.inProgress, 0);
            const totalTodo = Array.from(workload.values()).reduce((sum, value) => sum + value.todo, 0);
            const blockedRate = totalItems === 0 ? '0.00' : ((totalBlocked / totalItems) * 100).toFixed(2);

            const renderStatusTable = (rows) => {
              const header = '| Field | Status | Details |\n| --- | --- | --- |';
              const body = rows.map((row) => {
                let badge = '✅';
                if (row.status === 'missing') badge = '❌';
                if (row.status !== 'ok') badge = '⚠️';
                return `| ${row.field} | ${badge} ${row.status} | ${row.reason} |`;
              });
              return `${header}\n${body.join('\n')}`;
            };

            const renderViewTable = (views) => {
              const header = '| View | Desc |';
              const sep = '| --- | --- |';
              const lines = views.map((view) => `| ${view.name} | ${view.desc} |`);
              return `${header}\n${sep}\n${lines.join('\n')}`;
            };

            const renderWorkload = (rows) => {
              const header = '| Assignee | To Do | In Progress | Blocked | Pending Effort |';
              const sep = '| --- | ---: | ---: | ---: | ---: |';
              const lines = Array.from(rows.entries())
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([assignee, value]) =>
                  `| ${assignee} | ${value.todo} | ${value.inProgress} | ${value.blocked} | ${value.totalEstimate.toFixed(2)} |`);

              if (!lines.length) {
                return '| Assignee | To Do | In Progress | Blocked | Pending Effort |\n| --- | ---: | ---: | ---: | ---: |\n| - | 0 | 0 | 0 | 0 |';
              }

              return `${header}\n${sep}\n${lines.join('\n')}`;
            };

            const renderBlockedList = (rows) => {
              if (!rows.length) {
                return '- no blocked items';
              }

              return rows
                .slice(0, 12)
                .map((item) => `- [${item.title}](${item.url}) · ${item.assignee} · estimate ${item.estimate || 0}h · labels: ${item.labels}`)
                .join('\n');
            };

            const viewRows = (config.views || []).map((view) => ({
              name: view.name,
              desc: `${view.groupBy}; fields: ${(view.fields || []).join(', ')}; filter: ${view.filters || 'none'}; sort: ${view.sort || 'none'}`,
            }));

            const summaryProjectTitle = preflight?.node?.title || config.projectName || projectId;
            const summaryProjectLookupStatus = projectLookupError
              ? `Project lookup warning: ${String(projectLookupError).split('\n')[0]}`
              : 'Project lookup OK';

            const summaryBody = [
              `# Fiber Link Kanban Field/View Report (${isoDate})`,
              '',
              `Project: **${summaryProjectTitle}**`,
              `Project ID: '${projectId}'`,
              `Project status: **${summaryProjectLookupStatus}**`,
              `Trigger: ${context.eventName === 'workflow_dispatch' ? 'manual' : 'weekly schedule'}`,
              '',
              '## Field Config Check',
              renderStatusTable(requiredReport),
              '',
              '## Suggested Views',
              renderViewTable(viewRows),
              '',
              '## Weekly Snapshot by Issue/PR',
              [
                `- Total open items: **${totalItems}**`,
                `- In Progress: **${totalInProgress}**`,
                `- To Do: **${totalTodo}**`,
                `- Blocked: **${totalBlocked}** (blocked rate **${blockedRate}%**)`,
              ].join('\n'),
              '',
              renderWorkload(workload),
              '',
              '## Blocked list (top 12)',
              renderBlockedList(blockedItems),
              '',
              '### Notes',
              '- `Status` is currently inferred from issue state and labels.',
              '- For stronger accuracy, drive `Status` directly in GitHub Project field.',
            ].join('\n');

            if (dryRunInput) {
              core.info('Dry run mode enabled, skip discussion update.');
              core.info(summaryBody);
              return;
            }

            if (!repoMeta?.repository?.id) {
              core.warning('No repository discussion metadata found; skip publishing field/view report to discussion.');
              core.info(summaryBody);
              return;
            }

            const categoryName = process.env.FIBER_LINK_DISCUSSION_CATEGORY || config.discussionCategory || 'General';
            const categories = repoMeta.repository?.discussionCategories?.nodes || [];
            const category =
              categories.find((item) => item.slug === categoryName.toLowerCase()) ||
              categories.find((item) => item.name.toLowerCase() === categoryName.toLowerCase()) ||
              categories[0];

            if (!category) {
              core.warning('Unable to determine discussion category, skip publishing field/view report to discussion.');
              core.info(summaryBody);
              return;
            }

            const createDiscussionMutation = `
              mutation($repositoryId: ID!, $categoryId: ID!, $title: String!, $body: String!) {
                createDiscussion(input: {
                  repositoryId: $repositoryId,
                  categoryId: $categoryId,
                  title: $title,
                  body: $body
                }) {
                  discussion {
                    id
                    url
                  }
                }
              }
            `;

            const title = `Fiber Link Kanban: field/view and workload report (${isoDate})`;

            try {
              const resp = await ghClient.graphql(createDiscussionMutation, {
                repositoryId: repoMeta.repository.id,
                categoryId: category.id,
                title,
                body: summaryBody,
              });

              core.info(`Discussion created: ${resp.createDiscussion.discussion.url}`);
            } catch (error) {
              core.warning(`Failed to publish discussion: ${(error && error.message) ? error.message : error}`);
              core.info(summaryBody);
              core.info('skip createDiscussion failure fallback: keep summary in logs for now.');
            }
